{"ast":null,"code":"import imageCompression from 'browser-image-compression';\n\n// Default fallback image URL from a public source\nexport const DEFAULT_TEDDY_IMAGE = 'https://res.cloudinary.com/davjxvz8w/image/upload/v1695721605/teddy_bear_defaults/default-teddy.jpg';\n\n// Cloudinary configuration with explicit API key\nconst CLOUDINARY_CLOUD_NAME = 'davjxvz8w';\nconst UPLOAD_PRESET = 'ml_default';\n\n/**\n * Compresses an image file before upload\n */\nexport const compressImage = async file => {\n  if (!file) return null;\n  const options = {\n    maxSizeMB: 0.5,\n    // Make it smaller - 500KB\n    maxWidthOrHeight: 800,\n    // Smaller dimensions for better reliability\n    useWebWorker: true,\n    initialQuality: 0.7 // Slightly lower quality for better compression\n  };\n  try {\n    return await imageCompression(file, options);\n  } catch (error) {\n    console.error(\"Error compressing image:\", error);\n    return file; // Return original file if compression fails\n  }\n};\n\n/**\n * Uploads an image to Cloudinary with retries\n */\nexport const uploadToCloudinary = async (file, progressCallback = null) => {\n  if (!file) return null;\n\n  // Maximum number of upload attempts\n  const MAX_RETRY_ATTEMPTS = 3;\n  let currentAttempt = 0;\n  let lastError = null;\n  while (currentAttempt < MAX_RETRY_ATTEMPTS) {\n    try {\n      currentAttempt++;\n      console.log(`Cloudinary upload attempt ${currentAttempt} of ${MAX_RETRY_ATTEMPTS}`);\n\n      // First compress the image\n      const compressedFile = await compressImage(file);\n\n      // Generate a simpler filename\n      const timestamp = Date.now();\n      const uniqueId = Math.random().toString(36).substring(2, 10);\n      const safeFileName = file.name.replace(/[^a-zA-Z0-9.]/g, '_').substring(0, 20);\n\n      // Create form data for Cloudinary upload\n      const formData = new FormData();\n      formData.append('file', compressedFile);\n      formData.append('upload_preset', UPLOAD_PRESET);\n      formData.append('folder', 'teddy_bears');\n      formData.append('public_id', `teddy_${timestamp}_${uniqueId}`);\n      console.log(\"Starting Cloudinary upload with preset:\", UPLOAD_PRESET);\n\n      // Use a timeout promise to ensure the request doesn't hang\n      const uploadPromise = fetch(`https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/image/upload`, {\n        method: 'POST',\n        body: formData\n      });\n\n      // Add a timeout to the fetch request\n      const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Upload request timed out')), 30000));\n\n      // Race the fetch against the timeout\n      const response = await Promise.race([uploadPromise, timeoutPromise]);\n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`Cloudinary API error (${response.status}): ${errorText}`);\n      }\n      const data = await response.json();\n      console.log(\"Cloudinary upload successful:\", data);\n\n      // Return the data with the image URL\n      return {\n        url: data.secure_url,\n        publicId: data.public_id,\n        provider: 'cloudinary',\n        width: data.width,\n        height: data.height\n      };\n    } catch (error) {\n      lastError = error;\n      console.error(`Upload attempt ${currentAttempt} failed:`, error);\n\n      // If this wasn't our last attempt, wait before trying again\n      if (currentAttempt < MAX_RETRY_ATTEMPTS) {\n        const delay = 1000 * currentAttempt; // Increase delay with each attempt\n        console.log(`Waiting ${delay}ms before retry...`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  }\n\n  // If we've exhausted all retry attempts, throw the last error\n  console.error(\"All upload attempts failed\");\n  throw lastError || new Error(\"Failed to upload image after multiple attempts\");\n};\n\n/**\n * Fallback to direct base64 encoding\n */\nconst convertToBase64 = file => {\n  return new Promise((resolve, reject) => {\n    try {\n      // Check if file size is too large for base64\n      if (file.size > 1024 * 1024) {\n        // Over 1MB\n        // Try to compress it first\n        imageCompression(file, {\n          maxSizeMB: 0.3,\n          // Very aggressive compression\n          maxWidthOrHeight: 600,\n          initialQuality: 0.5\n        }).then(compressedFile => {\n          const reader = new FileReader();\n          reader.readAsDataURL(compressedFile);\n          reader.onload = () => resolve(reader.result);\n          reader.onerror = error => reject(error);\n        }).catch(error => reject(error));\n      } else {\n        // Small enough for direct conversion\n        const reader = new FileReader();\n        reader.readAsDataURL(file);\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = error => reject(error);\n      }\n    } catch (error) {\n      reject(error);\n    }\n  });\n};\n\n/**\n * Handle image upload with multiple fallbacks for reliability\n */\nexport const handleImageUpload = async (file, progressCallback = null) => {\n  if (!file) {\n    return {\n      url: DEFAULT_TEDDY_IMAGE,\n      publicId: 'default_teddy',\n      provider: 'default'\n    };\n  }\n  try {\n    // First attempt to upload to Cloudinary\n    const result = await uploadToCloudinary(file, progressCallback);\n\n    // Verify the result has valid data\n    if (!result || !result.url) {\n      throw new Error(\"Invalid response from Cloudinary\");\n    }\n\n    // Make sure the URL is valid\n    try {\n      new URL(result.url);\n    } catch (urlError) {\n      throw new Error(\"Invalid URL returned from Cloudinary\");\n    }\n    console.log(\"Image uploaded successfully:\", result.url);\n    return result;\n  } catch (cloudinaryError) {\n    console.error(\"Cloudinary upload failed:\", cloudinaryError);\n    try {\n      console.log(\"Falling back to base64 encoding...\");\n      const base64Data = await convertToBase64(file);\n\n      // Verify the base64 data is valid\n      if (!base64Data || !base64Data.startsWith('data:image/')) {\n        throw new Error(\"Invalid base64 data\");\n      }\n      return {\n        url: base64Data,\n        publicId: 'base64_image_' + Date.now(),\n        provider: 'base64'\n      };\n    } catch (base64Error) {\n      console.error(\"Base64 fallback also failed:\", base64Error);\n\n      // Final fallback - return default image\n      console.log(\"Using default teddy bear image\");\n      return {\n        url: DEFAULT_TEDDY_IMAGE,\n        publicId: 'default_teddy',\n        provider: 'default'\n      };\n    }\n  }\n};\n\n/**\n * Test if an image URL is accessible\n */\nexport const checkImageUrl = async url => {\n  // Skip checking base64 images\n  if (url && url.startsWith('data:image/')) {\n    return true;\n  }\n  try {\n    if (!url) return false;\n\n    // Try to fetch with a HEAD request and a short timeout\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 5000);\n    const response = await fetch(url, {\n      method: 'HEAD',\n      signal: controller.signal,\n      mode: 'no-cors' // This helps with CORS issues\n    });\n    clearTimeout(timeoutId);\n    return true; // If we get here without errors, the image is probably accessible\n  } catch (error) {\n    console.error(\"Error checking image URL:\", error);\n    return false;\n  }\n};","map":{"version":3,"names":["imageCompression","DEFAULT_TEDDY_IMAGE","CLOUDINARY_CLOUD_NAME","UPLOAD_PRESET","compressImage","file","options","maxSizeMB","maxWidthOrHeight","useWebWorker","initialQuality","error","console","uploadToCloudinary","progressCallback","MAX_RETRY_ATTEMPTS","currentAttempt","lastError","log","compressedFile","timestamp","Date","now","uniqueId","Math","random","toString","substring","safeFileName","name","replace","formData","FormData","append","uploadPromise","fetch","method","body","timeoutPromise","Promise","_","reject","setTimeout","Error","response","race","ok","errorText","text","status","data","json","url","secure_url","publicId","public_id","provider","width","height","delay","resolve","convertToBase64","size","then","reader","FileReader","readAsDataURL","onload","result","onerror","catch","handleImageUpload","URL","urlError","cloudinaryError","base64Data","startsWith","base64Error","checkImageUrl","controller","AbortController","timeoutId","abort","signal","mode","clearTimeout"],"sources":["/Users/yeduruabhiram/Desktop/suresh ment01/src/utils/cloudinaryUpload.js"],"sourcesContent":["import imageCompression from 'browser-image-compression';\n\n// Default fallback image URL from a public source\nexport const DEFAULT_TEDDY_IMAGE = 'https://res.cloudinary.com/davjxvz8w/image/upload/v1695721605/teddy_bear_defaults/default-teddy.jpg';\n\n// Cloudinary configuration with explicit API key\nconst CLOUDINARY_CLOUD_NAME = 'davjxvz8w';\nconst UPLOAD_PRESET = 'ml_default';\n\n/**\n * Compresses an image file before upload\n */\nexport const compressImage = async (file) => {\n  if (!file) return null;\n  \n  const options = {\n    maxSizeMB: 0.5, // Make it smaller - 500KB\n    maxWidthOrHeight: 800, // Smaller dimensions for better reliability\n    useWebWorker: true,\n    initialQuality: 0.7 // Slightly lower quality for better compression\n  };\n  \n  try {\n    return await imageCompression(file, options);\n  } catch (error) {\n    console.error(\"Error compressing image:\", error);\n    return file; // Return original file if compression fails\n  }\n};\n\n/**\n * Uploads an image to Cloudinary with retries\n */\nexport const uploadToCloudinary = async (file, progressCallback = null) => {\n  if (!file) return null;\n  \n  // Maximum number of upload attempts\n  const MAX_RETRY_ATTEMPTS = 3;\n  let currentAttempt = 0;\n  let lastError = null;\n  \n  while (currentAttempt < MAX_RETRY_ATTEMPTS) {\n    try {\n      currentAttempt++;\n      console.log(`Cloudinary upload attempt ${currentAttempt} of ${MAX_RETRY_ATTEMPTS}`);\n      \n      // First compress the image\n      const compressedFile = await compressImage(file);\n      \n      // Generate a simpler filename\n      const timestamp = Date.now();\n      const uniqueId = Math.random().toString(36).substring(2, 10);\n      const safeFileName = file.name.replace(/[^a-zA-Z0-9.]/g, '_').substring(0, 20);\n      \n      // Create form data for Cloudinary upload\n      const formData = new FormData();\n      formData.append('file', compressedFile);\n      formData.append('upload_preset', UPLOAD_PRESET);\n      formData.append('folder', 'teddy_bears');\n      formData.append('public_id', `teddy_${timestamp}_${uniqueId}`);\n      \n      console.log(\"Starting Cloudinary upload with preset:\", UPLOAD_PRESET);\n      \n      // Use a timeout promise to ensure the request doesn't hang\n      const uploadPromise = fetch(\n        `https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/image/upload`,\n        {\n          method: 'POST',\n          body: formData\n        }\n      );\n      \n      // Add a timeout to the fetch request\n      const timeoutPromise = new Promise((_, reject) => \n        setTimeout(() => reject(new Error('Upload request timed out')), 30000)\n      );\n      \n      // Race the fetch against the timeout\n      const response = await Promise.race([uploadPromise, timeoutPromise]);\n      \n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`Cloudinary API error (${response.status}): ${errorText}`);\n      }\n      \n      const data = await response.json();\n      console.log(\"Cloudinary upload successful:\", data);\n      \n      // Return the data with the image URL\n      return {\n        url: data.secure_url,\n        publicId: data.public_id,\n        provider: 'cloudinary',\n        width: data.width,\n        height: data.height\n      };\n      \n    } catch (error) {\n      lastError = error;\n      console.error(`Upload attempt ${currentAttempt} failed:`, error);\n      \n      // If this wasn't our last attempt, wait before trying again\n      if (currentAttempt < MAX_RETRY_ATTEMPTS) {\n        const delay = 1000 * currentAttempt; // Increase delay with each attempt\n        console.log(`Waiting ${delay}ms before retry...`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  }\n  \n  // If we've exhausted all retry attempts, throw the last error\n  console.error(\"All upload attempts failed\");\n  throw lastError || new Error(\"Failed to upload image after multiple attempts\");\n};\n\n/**\n * Fallback to direct base64 encoding\n */\nconst convertToBase64 = (file) => {\n  return new Promise((resolve, reject) => {\n    try {\n      // Check if file size is too large for base64\n      if (file.size > 1024 * 1024) { // Over 1MB\n        // Try to compress it first\n        imageCompression(file, {\n          maxSizeMB: 0.3, // Very aggressive compression\n          maxWidthOrHeight: 600,\n          initialQuality: 0.5\n        }).then(compressedFile => {\n          const reader = new FileReader();\n          reader.readAsDataURL(compressedFile);\n          reader.onload = () => resolve(reader.result);\n          reader.onerror = (error) => reject(error);\n        }).catch(error => reject(error));\n      } else {\n        // Small enough for direct conversion\n        const reader = new FileReader();\n        reader.readAsDataURL(file);\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = (error) => reject(error);\n      }\n    } catch (error) {\n      reject(error);\n    }\n  });\n};\n\n/**\n * Handle image upload with multiple fallbacks for reliability\n */\nexport const handleImageUpload = async (file, progressCallback = null) => {\n  if (!file) {\n    return {\n      url: DEFAULT_TEDDY_IMAGE,\n      publicId: 'default_teddy',\n      provider: 'default'\n    };\n  }\n  \n  try {\n    // First attempt to upload to Cloudinary\n    const result = await uploadToCloudinary(file, progressCallback);\n    \n    // Verify the result has valid data\n    if (!result || !result.url) {\n      throw new Error(\"Invalid response from Cloudinary\");\n    }\n    \n    // Make sure the URL is valid\n    try {\n      new URL(result.url);\n    } catch (urlError) {\n      throw new Error(\"Invalid URL returned from Cloudinary\");\n    }\n    \n    console.log(\"Image uploaded successfully:\", result.url);\n    return result;\n  } catch (cloudinaryError) {\n    console.error(\"Cloudinary upload failed:\", cloudinaryError);\n    \n    try {\n      console.log(\"Falling back to base64 encoding...\");\n      const base64Data = await convertToBase64(file);\n      \n      // Verify the base64 data is valid\n      if (!base64Data || !base64Data.startsWith('data:image/')) {\n        throw new Error(\"Invalid base64 data\");\n      }\n      \n      return {\n        url: base64Data,\n        publicId: 'base64_image_' + Date.now(),\n        provider: 'base64'\n      };\n    } catch (base64Error) {\n      console.error(\"Base64 fallback also failed:\", base64Error);\n      \n      // Final fallback - return default image\n      console.log(\"Using default teddy bear image\");\n      return {\n        url: DEFAULT_TEDDY_IMAGE,\n        publicId: 'default_teddy',\n        provider: 'default'\n      };\n    }\n  }\n};\n\n/**\n * Test if an image URL is accessible\n */\nexport const checkImageUrl = async (url) => {\n  // Skip checking base64 images\n  if (url && url.startsWith('data:image/')) {\n    return true;\n  }\n  \n  try {\n    if (!url) return false;\n    \n    // Try to fetch with a HEAD request and a short timeout\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 5000);\n    \n    const response = await fetch(url, { \n      method: 'HEAD',\n      signal: controller.signal,\n      mode: 'no-cors' // This helps with CORS issues\n    });\n    \n    clearTimeout(timeoutId);\n    return true; // If we get here without errors, the image is probably accessible\n  } catch (error) {\n    console.error(\"Error checking image URL:\", error);\n    return false;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}