{"ast":null,"code":"import imageCompression from 'browser-image-compression';\n\n// Default fallback image URL from a public source\nexport const DEFAULT_TEDDY_IMAGE = 'https://res.cloudinary.com/davjxvz8w/image/upload/v1695721605/teddy_bear_defaults/default-teddy.jpg';\n\n// Cloudinary configuration\nconst CLOUDINARY_CLOUD_NAME = 'davjxvz8w';\n// Updated to a simpler, more common preset name\nconst UPLOAD_PRESET = 'ml_default';\n\n/**\n * Compresses an image file before upload\n */\nexport const compressImage = async file => {\n  if (!file) return null;\n  const options = {\n    maxSizeMB: 0.8,\n    // Compress to 800KB\n    maxWidthOrHeight: 1200,\n    useWebWorker: true,\n    initialQuality: 0.8\n  };\n  try {\n    return await imageCompression(file, options);\n  } catch (error) {\n    console.error(\"Error compressing image:\", error);\n    return file; // Return original file if compression fails\n  }\n};\n\n/**\n * Uploads an image to Cloudinary using the unsigned preset\n */\nexport const uploadToCloudinary = async (file, progressCallback = null) => {\n  if (!file) return null;\n  try {\n    // First compress the image\n    const compressedFile = await compressImage(file);\n\n    // Generate folder path based on timestamp\n    const timestamp = new Date().getTime();\n    const folderPath = `teddy_bears`;\n\n    // Create form data for Cloudinary upload\n    const formData = new FormData();\n    formData.append('file', compressedFile);\n    formData.append('upload_preset', UPLOAD_PRESET);\n    formData.append('folder', folderPath);\n    // Add a public filename for better identification\n    const uniqueFilename = `teddy_${timestamp}_${file.name.replace(/\\s+/g, '_')}`;\n    formData.append('public_id', uniqueFilename);\n    console.log(\"Starting Cloudinary upload with preset:\", UPLOAD_PRESET);\n\n    // Make a fetch request instead of using XMLHttpRequest\n    const response = await fetch(`https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/image/upload`, {\n      method: 'POST',\n      body: formData\n    });\n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error(\"Cloudinary API error:\", errorText);\n      throw new Error(`Upload failed with status: ${response.status}`);\n    }\n    const data = await response.json();\n    console.log(\"Cloudinary upload response:\", data);\n\n    // Make sure the URL is properly formatted and accessible\n    return {\n      url: data.secure_url,\n      publicId: data.public_id,\n      provider: 'cloudinary',\n      width: data.width,\n      height: data.height\n    };\n  } catch (error) {\n    console.error(\"Error in Cloudinary upload:\", error);\n    throw error;\n  }\n};\n\n/**\n * Handle image upload with improved error handling\n */\nexport const handleImageUpload = async (file, progressCallback = null) => {\n  if (!file) {\n    return {\n      url: DEFAULT_TEDDY_IMAGE,\n      publicId: 'default_teddy',\n      provider: 'default'\n    };\n  }\n  try {\n    // First attempt to upload to Cloudinary\n    const result = await uploadToCloudinary(file, progressCallback);\n\n    // Verify the URL is valid and accessible\n    const checkUrl = new URL(result.url);\n    if (!checkUrl.pathname) {\n      throw new Error(\"Invalid image URL returned\");\n    }\n    console.log(\"Successfully uploaded image:\", result.url);\n    return result;\n  } catch (error) {\n    console.error(\"Cloudinary upload failed:\", error);\n\n    // As a fallback, convert the image to base64\n    try {\n      console.log(\"Attempting base64 conversion as fallback...\");\n      const base64 = await convertToBase64(file);\n      return {\n        url: base64,\n        publicId: 'base64_image',\n        provider: 'base64'\n      };\n    } catch (base64Error) {\n      console.error(\"Base64 conversion also failed:\", base64Error);\n\n      // Return default image as last resort\n      return {\n        url: DEFAULT_TEDDY_IMAGE,\n        publicId: 'default_teddy',\n        provider: 'default'\n      };\n    }\n  }\n};\n\n/**\n * Convert image to base64 as fallback\n */\nconst convertToBase64 = file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.readAsDataURL(file);\n    reader.onload = () => resolve(reader.result);\n    reader.onerror = error => reject(error);\n  });\n};\n\n/**\n * Test if an image URL is accessible\n */\nexport const checkImageUrl = async url => {\n  try {\n    const response = await fetch(url, {\n      method: 'HEAD'\n    });\n    return response.ok;\n  } catch (error) {\n    console.error(\"Error checking image URL:\", error);\n    return false;\n  }\n};","map":{"version":3,"names":["imageCompression","DEFAULT_TEDDY_IMAGE","CLOUDINARY_CLOUD_NAME","UPLOAD_PRESET","compressImage","file","options","maxSizeMB","maxWidthOrHeight","useWebWorker","initialQuality","error","console","uploadToCloudinary","progressCallback","compressedFile","timestamp","Date","getTime","folderPath","formData","FormData","append","uniqueFilename","name","replace","log","response","fetch","method","body","ok","errorText","text","Error","status","data","json","url","secure_url","publicId","public_id","provider","width","height","handleImageUpload","result","checkUrl","URL","pathname","base64","convertToBase64","base64Error","Promise","resolve","reject","reader","FileReader","readAsDataURL","onload","onerror","checkImageUrl"],"sources":["/Users/yeduruabhiram/Desktop/suresh ment01/src/utils/cloudinaryUpload.js"],"sourcesContent":["import imageCompression from 'browser-image-compression';\n\n// Default fallback image URL from a public source\nexport const DEFAULT_TEDDY_IMAGE = 'https://res.cloudinary.com/davjxvz8w/image/upload/v1695721605/teddy_bear_defaults/default-teddy.jpg';\n\n// Cloudinary configuration\nconst CLOUDINARY_CLOUD_NAME = 'davjxvz8w';\n// Updated to a simpler, more common preset name\nconst UPLOAD_PRESET = 'ml_default';\n\n/**\n * Compresses an image file before upload\n */\nexport const compressImage = async (file) => {\n  if (!file) return null;\n  \n  const options = {\n    maxSizeMB: 0.8, // Compress to 800KB\n    maxWidthOrHeight: 1200,\n    useWebWorker: true,\n    initialQuality: 0.8\n  };\n  \n  try {\n    return await imageCompression(file, options);\n  } catch (error) {\n    console.error(\"Error compressing image:\", error);\n    return file; // Return original file if compression fails\n  }\n};\n\n/**\n * Uploads an image to Cloudinary using the unsigned preset\n */\nexport const uploadToCloudinary = async (file, progressCallback = null) => {\n  if (!file) return null;\n  \n  try {\n    // First compress the image\n    const compressedFile = await compressImage(file);\n    \n    // Generate folder path based on timestamp\n    const timestamp = new Date().getTime();\n    const folderPath = `teddy_bears`;\n    \n    // Create form data for Cloudinary upload\n    const formData = new FormData();\n    formData.append('file', compressedFile);\n    formData.append('upload_preset', UPLOAD_PRESET);\n    formData.append('folder', folderPath);\n    // Add a public filename for better identification\n    const uniqueFilename = `teddy_${timestamp}_${file.name.replace(/\\s+/g, '_')}`;\n    formData.append('public_id', uniqueFilename);\n    \n    console.log(\"Starting Cloudinary upload with preset:\", UPLOAD_PRESET);\n    \n    // Make a fetch request instead of using XMLHttpRequest\n    const response = await fetch(\n      `https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/image/upload`,\n      {\n        method: 'POST',\n        body: formData\n      }\n    );\n    \n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error(\"Cloudinary API error:\", errorText);\n      throw new Error(`Upload failed with status: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    console.log(\"Cloudinary upload response:\", data);\n    \n    // Make sure the URL is properly formatted and accessible\n    return {\n      url: data.secure_url,\n      publicId: data.public_id,\n      provider: 'cloudinary',\n      width: data.width,\n      height: data.height\n    };\n  } catch (error) {\n    console.error(\"Error in Cloudinary upload:\", error);\n    throw error;\n  }\n};\n\n/**\n * Handle image upload with improved error handling\n */\nexport const handleImageUpload = async (file, progressCallback = null) => {\n  if (!file) {\n    return {\n      url: DEFAULT_TEDDY_IMAGE,\n      publicId: 'default_teddy',\n      provider: 'default'\n    };\n  }\n  \n  try {\n    // First attempt to upload to Cloudinary\n    const result = await uploadToCloudinary(file, progressCallback);\n    \n    // Verify the URL is valid and accessible\n    const checkUrl = new URL(result.url);\n    if (!checkUrl.pathname) {\n      throw new Error(\"Invalid image URL returned\");\n    }\n    \n    console.log(\"Successfully uploaded image:\", result.url);\n    return result;\n  } catch (error) {\n    console.error(\"Cloudinary upload failed:\", error);\n    \n    // As a fallback, convert the image to base64\n    try {\n      console.log(\"Attempting base64 conversion as fallback...\");\n      const base64 = await convertToBase64(file);\n      return {\n        url: base64,\n        publicId: 'base64_image',\n        provider: 'base64'\n      };\n    } catch (base64Error) {\n      console.error(\"Base64 conversion also failed:\", base64Error);\n      \n      // Return default image as last resort\n      return {\n        url: DEFAULT_TEDDY_IMAGE,\n        publicId: 'default_teddy',\n        provider: 'default'\n      };\n    }\n  }\n};\n\n/**\n * Convert image to base64 as fallback\n */\nconst convertToBase64 = (file) => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.readAsDataURL(file);\n    reader.onload = () => resolve(reader.result);\n    reader.onerror = (error) => reject(error);\n  });\n};\n\n/**\n * Test if an image URL is accessible\n */\nexport const checkImageUrl = async (url) => {\n  try {\n    const response = await fetch(url, { method: 'HEAD' });\n    return response.ok;\n  } catch (error) {\n    console.error(\"Error checking image URL:\", error);\n    return false;\n  }\n};\n"],"mappings":"AAAA,OAAOA,gBAAgB,MAAM,2BAA2B;;AAExD;AACA,OAAO,MAAMC,mBAAmB,GAAG,qGAAqG;;AAExI;AACA,MAAMC,qBAAqB,GAAG,WAAW;AACzC;AACA,MAAMC,aAAa,GAAG,YAAY;;AAElC;AACA;AACA;AACA,OAAO,MAAMC,aAAa,GAAG,MAAOC,IAAI,IAAK;EAC3C,IAAI,CAACA,IAAI,EAAE,OAAO,IAAI;EAEtB,MAAMC,OAAO,GAAG;IACdC,SAAS,EAAE,GAAG;IAAE;IAChBC,gBAAgB,EAAE,IAAI;IACtBC,YAAY,EAAE,IAAI;IAClBC,cAAc,EAAE;EAClB,CAAC;EAED,IAAI;IACF,OAAO,MAAMV,gBAAgB,CAACK,IAAI,EAAEC,OAAO,CAAC;EAC9C,CAAC,CAAC,OAAOK,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;IAChD,OAAON,IAAI,CAAC,CAAC;EACf;AACF,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMQ,kBAAkB,GAAG,MAAAA,CAAOR,IAAI,EAAES,gBAAgB,GAAG,IAAI,KAAK;EACzE,IAAI,CAACT,IAAI,EAAE,OAAO,IAAI;EAEtB,IAAI;IACF;IACA,MAAMU,cAAc,GAAG,MAAMX,aAAa,CAACC,IAAI,CAAC;;IAEhD;IACA,MAAMW,SAAS,GAAG,IAAIC,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;IACtC,MAAMC,UAAU,GAAG,aAAa;;IAEhC;IACA,MAAMC,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;IAC/BD,QAAQ,CAACE,MAAM,CAAC,MAAM,EAAEP,cAAc,CAAC;IACvCK,QAAQ,CAACE,MAAM,CAAC,eAAe,EAAEnB,aAAa,CAAC;IAC/CiB,QAAQ,CAACE,MAAM,CAAC,QAAQ,EAAEH,UAAU,CAAC;IACrC;IACA,MAAMI,cAAc,GAAG,SAASP,SAAS,IAAIX,IAAI,CAACmB,IAAI,CAACC,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,EAAE;IAC7EL,QAAQ,CAACE,MAAM,CAAC,WAAW,EAAEC,cAAc,CAAC;IAE5CX,OAAO,CAACc,GAAG,CAAC,yCAAyC,EAAEvB,aAAa,CAAC;;IAErE;IACA,MAAMwB,QAAQ,GAAG,MAAMC,KAAK,CAC1B,mCAAmC1B,qBAAqB,eAAe,EACvE;MACE2B,MAAM,EAAE,MAAM;MACdC,IAAI,EAAEV;IACR,CACF,CAAC;IAED,IAAI,CAACO,QAAQ,CAACI,EAAE,EAAE;MAChB,MAAMC,SAAS,GAAG,MAAML,QAAQ,CAACM,IAAI,CAAC,CAAC;MACvCrB,OAAO,CAACD,KAAK,CAAC,uBAAuB,EAAEqB,SAAS,CAAC;MACjD,MAAM,IAAIE,KAAK,CAAC,8BAA8BP,QAAQ,CAACQ,MAAM,EAAE,CAAC;IAClE;IAEA,MAAMC,IAAI,GAAG,MAAMT,QAAQ,CAACU,IAAI,CAAC,CAAC;IAClCzB,OAAO,CAACc,GAAG,CAAC,6BAA6B,EAAEU,IAAI,CAAC;;IAEhD;IACA,OAAO;MACLE,GAAG,EAAEF,IAAI,CAACG,UAAU;MACpBC,QAAQ,EAAEJ,IAAI,CAACK,SAAS;MACxBC,QAAQ,EAAE,YAAY;MACtBC,KAAK,EAAEP,IAAI,CAACO,KAAK;MACjBC,MAAM,EAAER,IAAI,CAACQ;IACf,CAAC;EACH,CAAC,CAAC,OAAOjC,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;IACnD,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMkC,iBAAiB,GAAG,MAAAA,CAAOxC,IAAI,EAAES,gBAAgB,GAAG,IAAI,KAAK;EACxE,IAAI,CAACT,IAAI,EAAE;IACT,OAAO;MACLiC,GAAG,EAAErC,mBAAmB;MACxBuC,QAAQ,EAAE,eAAe;MACzBE,QAAQ,EAAE;IACZ,CAAC;EACH;EAEA,IAAI;IACF;IACA,MAAMI,MAAM,GAAG,MAAMjC,kBAAkB,CAACR,IAAI,EAAES,gBAAgB,CAAC;;IAE/D;IACA,MAAMiC,QAAQ,GAAG,IAAIC,GAAG,CAACF,MAAM,CAACR,GAAG,CAAC;IACpC,IAAI,CAACS,QAAQ,CAACE,QAAQ,EAAE;MACtB,MAAM,IAAIf,KAAK,CAAC,4BAA4B,CAAC;IAC/C;IAEAtB,OAAO,CAACc,GAAG,CAAC,8BAA8B,EAAEoB,MAAM,CAACR,GAAG,CAAC;IACvD,OAAOQ,MAAM;EACf,CAAC,CAAC,OAAOnC,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;;IAEjD;IACA,IAAI;MACFC,OAAO,CAACc,GAAG,CAAC,6CAA6C,CAAC;MAC1D,MAAMwB,MAAM,GAAG,MAAMC,eAAe,CAAC9C,IAAI,CAAC;MAC1C,OAAO;QACLiC,GAAG,EAAEY,MAAM;QACXV,QAAQ,EAAE,cAAc;QACxBE,QAAQ,EAAE;MACZ,CAAC;IACH,CAAC,CAAC,OAAOU,WAAW,EAAE;MACpBxC,OAAO,CAACD,KAAK,CAAC,gCAAgC,EAAEyC,WAAW,CAAC;;MAE5D;MACA,OAAO;QACLd,GAAG,EAAErC,mBAAmB;QACxBuC,QAAQ,EAAE,eAAe;QACzBE,QAAQ,EAAE;MACZ,CAAC;IACH;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA,MAAMS,eAAe,GAAI9C,IAAI,IAAK;EAChC,OAAO,IAAIgD,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtC,MAAMC,MAAM,GAAG,IAAIC,UAAU,CAAC,CAAC;IAC/BD,MAAM,CAACE,aAAa,CAACrD,IAAI,CAAC;IAC1BmD,MAAM,CAACG,MAAM,GAAG,MAAML,OAAO,CAACE,MAAM,CAACV,MAAM,CAAC;IAC5CU,MAAM,CAACI,OAAO,GAAIjD,KAAK,IAAK4C,MAAM,CAAC5C,KAAK,CAAC;EAC3C,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMkD,aAAa,GAAG,MAAOvB,GAAG,IAAK;EAC1C,IAAI;IACF,MAAMX,QAAQ,GAAG,MAAMC,KAAK,CAACU,GAAG,EAAE;MAAET,MAAM,EAAE;IAAO,CAAC,CAAC;IACrD,OAAOF,QAAQ,CAACI,EAAE;EACpB,CAAC,CAAC,OAAOpB,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;IACjD,OAAO,KAAK;EACd;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}